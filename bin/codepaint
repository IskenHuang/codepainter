#!/usr/bin/env node

var clc = require('cli-color');
var crypto = require('crypto');
var editorconfig = require('editorconfig');
var extend = require('node.extend');
var fs = require('fs');
var glob = require('glob');
var path = require('path');
var program = require('commander');

var package = require("../package.json");
var Transformer = require('../lib/Transformer');


var style = {};

function setting(val) {
	return keyValue(val, style);
}

function keyValue(val, store) {
	val = val.split('=');
	store[val[0]] = parseValue(val[1]);
	return val;
}

function parseValue(value){
	try {
		return JSON.parse(value);
	} catch(e){
		return value;
	}
}

program.version('Code Painter ' + package.version + ' beautifies JavaScript.');

program
.usage(['[options] "glob" ["glob" ...]', program._version].join("\n\n  "))
.option('-i, --infer <path>',			'code sample to infer')
.option('-p, --predef <name>',			'specify predefined style (idiomatic|...)')
.option('-j, --json <path>',			'JSON file with style settings')
.option('-s, --style <key>=<value>',	'an individual style setting', setting)
.option('-e, --editor-config',			'enable rules via EditorConfig')
.option('-C, --no-color',				'disable color escape codes')
.parse(process.argv);

program.on('--help', function(){
	console.log('  Examples:');
	console.log('');
	console.log('    $', clc.cyan('codepaint "**/*.js"'));
	console.log('    $ codepaint', clc.cyan('"**/*view.js" "**/*model.js"'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-i sample.js'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-p idiomatic'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-j custom.json'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-s quote_type=null'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-s indent_style=space -s indent_size=4'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-e'));
	console.log('');
});

if (program.rawArgs.length === 2) {
	program.help();
}

program.style = style;
program.globs = program.args;

function error(msg){
	msg = 'Error: ' + msg;
	if (program.color) {
		msg = clc.red(msg);
	}
	msg = '\n  ' + msg;
	if (typeof arguments[1] !== 'undefined') {
		console.log(msg, arguments[1]);
	} else {
		console.log(msg);
	}
}

function cascade(styleBefore, styleToMerge, styleType){
	if (Object.keys(styleToMerge).length === 0){
		return;
	}
	console.log('');
	console.log('  ' + styleType + ':');
	var color;
	Object.keys(styleToMerge).forEach(function(key){
		var msg = key + ' = ' + styleToMerge[key];
		if (key in style) {
			if (style[key] === styleToMerge[key]){
				msg = '= ' + msg;
				color = clc.blackBright;
			} else if (styleToMerge[key] === null){
				msg = '   x ' + msg;
				delete style[key];
				console.log(program.color ? clc.red(msg) : msg);
				return;
			} else {
				msg = '* ' + msg;
				color = clc.cyan;
			}
		} else {
			msg = '+ ' + msg;
			color = clc.green;
		}
		console.log('   ' + (program.color ? color(msg) : msg));
	});
}

var transformer = new Transformer(program);

transformer.on('cascade', cascade);

transformer.once('transform', function(){
	process.stdout.write('\n  ');
});

transformer.on('transform', function(transformed, path){
	if (transformed % 70 === 0) {
		process.stdout.write('\n  ');
	}
	process.stdout.write('.');
});

transformer.on('end', function(err, transformed, skipped){
	console.log('');
	if (err) error(err.message);
	displayFinalMessage(transformed, 'transformed', skipped);
});

transformer.transform();

// function traverseGlobs(style) {
// 	var filesMatched = 0;
// 	var filesSkipped = 0;
// 	var filesTransformed = 0;
// 	var inputs = [];
// 	config.globs.forEach(function(globPattern){
// 		var files = glob.sync(globPattern);
// 		inputs.push.apply(inputs, files.filter(filterOutExisting));
// 	});
// 	if ( ! inputs.length || (config.globs.length && program.rawArgs.length === 3)){
// 		displayFinalMessage(inputs.length, 'matched');
// 		program.help();
// 	} else {
// 		filesMatched = inputs.length;
// 		process.stdout.write('\n  ');
// 		inputs.forEach(function(inputPath){
// 			applyEditorConfigSettingsAndTransform(path.resolve(inputPath), style, onTransformEnd);
// 		});
// 	}
// 	function filterOutExisting(file){
// 		return inputs.indexOf(file) === -1;
// 	}
// 	function onTransformEnd(isTransformed) {
// 		if (isTransformed === false) {
// 			filesSkipped++;
// 		} else {
// 			if (++filesTransformed % 70 === 0) {
// 				process.stdout.write('\n  ');
// 			}
// 			process.stdout.write('.');
// 		}
// 		if (filesTransformed + filesSkipped === filesMatched) {
// 			console.log('');
// 			displayFinalMessage(filesTransformed, 'transformed', filesSkipped);
// 		}
// 	}
// }

function displayFinalMessage(n, verb, skipped) {
	console.log('');
	var msg = '  REPORT: ' + n + ' file' + ((n === 1) ? '' : 's');
	msg += ' ' + verb;
	if (skipped) {
		msg += '. ' + skipped + ' files skipped (no rules to apply).';
	}
	if (program.color) {
		msg = clc.magenta(msg);
	}
	console.log(msg);
	console.log('');
	process.exit();
}
