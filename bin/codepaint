#!/usr/bin/env node

var clc = require('cli-color');
var crypto = require('crypto');
var editorconfig = require('editorconfig');
var extend = require('node.extend');
var fs = require('fs');
var glob = require('glob');
var path = require('path');
var program = require('commander');

var codepainter = require('../codepainter');
var package = require("../package.json");


var style = {};

function setting(val) {
	return keyValue(val, style);
}

function keyValue(val, store) {
	val = val.split('=');
	store[val[0]] = parseValue(val[1]);
	return val;
}

function parseValue(value){
	try {
		return JSON.parse(value);
	} catch(e){
		return value;
	}
}

program.version('Code Painter ' + package.version + ' beautifies JavaScript.');

program
.usage(['[options] "glob" ["glob" ...]', program._version].join("\n\n  "))
.option('-i, --infer <path>',			'code sample to infer')
.option('-p, --predef <name>',			'specify predefined style (idiomatic|...)')
.option('-j, --json <path>',			'JSON file with style settings')
.option('-s, --style <key>=<value>',	'an individual style setting', setting)
.option('-e, --editor-config',			'enable rules via EditorConfig')
.option('-C, --no-color',				'disable color escape codes')
.parse(process.argv);

program.on('--help', function(){
	console.log('  Examples:');
	console.log('');
	console.log('    $', clc.cyan('codepaint "**/*.js"'));
	console.log('    $ codepaint', clc.cyan('"**/*view.js" "**/*model.js"'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-i sample.js'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-p idiomatic'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-j custom.json'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-s quote_type=null'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-s indent_style=space -s indent_size=4'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-e'));
	console.log('');
});

if (program.rawArgs.length === 2) {
	program.help();
}

var config = {useColors : program.color};

function error(msg){
	msg = 'Error: ' + msg;
	if (config.useColors) {
		msg = clc.red(msg);
	}
	msg = '\n  ' + msg;
	if (typeof arguments[1] !== 'undefined') {
		console.log(msg, arguments[1]);
	} else {
		console.log(msg);
	}
	program.help();
}

config = extend(config, {
	infer : program.infer && resolveCheckPath(program.infer),
	predef : program.predef && resolveCheckPath(__dirname + '/../lib/styles/' + program.predef + '.json'),
	json : program.json && resolveCheckPath(program.json),
	style : style,
	globs : program.args
});

function resolveCheckPath(p){
	if (typeof p === 'undefined'){
		return;
	}
	var resolvedPath = path.resolve(p);
	if ( ! fs.existsSync(resolvedPath)){
		error('path %s does not exist', p);
	}
	return resolvedPath;
}

style = {};

if (program.infer){
	var stream = fs.createReadStream(program.infer);
	stream.pause();
	stream.setEncoding('utf-8');
	codepainter.infer(stream, function(inferredStyle){
		reportStyle(inferredStyle, 'Inferred style');
		cascadeStyles();
	});
	stream.resume();
} else {
	cascadeStyles();
}

function reportStyle(styleObj, styleType){
	if (Object.keys(styleObj).length === 0){
		return;
	}
	console.log('');
	console.log('  ' + styleType + ':');
	var color;
	for (var key in styleObj){
		if (styleObj.hasOwnProperty(key)){
			var msg = key + ' = ' + styleObj[key];
			if (key in style) {
				if (style[key] === styleObj[key]){
					msg = '= ' + msg;
					color = clc.blackBright;
				} else if (styleObj[key] === null){
					msg = '   x ' + msg;
					delete style[key];
					console.log(config.useColors ? clc.red(msg) : msg);
					continue;
				} else {
					msg = '* ' + msg;
					color = clc.cyan;
				}
			} else {
				msg = '+ ' + msg;
				color = clc.green;
			}
			style[key] = styleObj[key];
			console.log('   ' + (config.useColors ? color(msg) : msg));
		}
	}
}

function cascadeStyles(){
	try {

		if (program.predef){
			var predefStyle = require('../lib/styles/' + program.predef + '.json');
			reportStyle(predefStyle, program.predef + ' style');
		}
		if (program.json){
			var jsonStyle = require(program.json);
			reportStyle(jsonStyle, 'Supplied JSON file');
		}
		if (config.style){
			reportStyle(config.style, 'Inline styles');
		}
		if (program.editorConfig){
			console.log('');
			console.log('  Editor Config:');
			var msg = '   + applied on a file-by-file basis';
			console.log(config.useColors ? clc.green(msg) : msg);
		}

	} catch(e) {
		error('JSON: ' + e.message);
		program.help();
	}

	traverseGlobs(style);
}

function traverseGlobs(style) {
	var filesMatched = 0;
	var filesSkipped = 0;
	var filesTransformed = 0;
	var inputs = [];
	config.globs.forEach(function(globPattern){
		var files = glob.sync(globPattern);
		inputs.push.apply(inputs, files.filter(filterOutExisting));
	});
	if ( ! inputs.length || (config.globs.length && program.rawArgs.length === 3)){
		displayFinalMessage(inputs.length, 'matched');
		program.help();
	} else {
		filesMatched = inputs.length;
		process.stdout.write('\n  ');
		inputs.forEach(function(inputPath){
			applyEditorConfigSettingsAndTransform(path.resolve(inputPath), style, onTransformEnd);
		});
	}
	function filterOutExisting(file){
		return inputs.indexOf(file) === -1;
	}
	function onTransformEnd(isTransformed) {
		if (isTransformed === false) {
			filesSkipped++;
		} else {
			if (++filesTransformed % 70 === 0) {
				process.stdout.write('\n  ');
			}
			process.stdout.write('.');
		}
		if (filesTransformed + filesSkipped === filesMatched) {
			console.log('');
			displayFinalMessage(filesTransformed, 'transformed', filesSkipped);
		}
	}
}

function applyEditorConfigSettingsAndTransform(inputPath, style, callback){
	if ( ! program.editorConfig){
		if (Object.keys(style).length){
			codepainter.transform(inputPath, style, callback);
		} else {
			callback(false);
		}
		return;
	}

	var editorConfigStyle = editorconfig.parse(inputPath);
	var cascadedStyle = extend({}, style, editorConfigStyle);

	if ( ! Object.keys(cascadedStyle).length){
		callback(false);
		return;
	}
	codepainter.transform(inputPath, cascadedStyle, callback);
}

function displayFinalMessage(n, verb, skipped) {
	console.log('');
	var msg = '  REPORT: ' + n + ' file' + ((n === 1) ? '' : 's');
	msg += ' ' + verb;
	if (skipped) {
		msg += '. ' + skipped + ' files skipped (no rules to apply).';
	}
	if (config.useColors) {
		msg = clc.magenta(msg);
	}
	console.log(msg);
	console.log('');
	process.exit();
}
